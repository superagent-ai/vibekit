import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  GrokConfig,
  GrokResponse,
  GrokStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class GrokAgent extends BaseAgent {
  private grokApiKey: string;
  private model?: string;
  private baseUrl?: string;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: GrokConfig) {
    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxProvider: config.sandboxProvider,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
      mcpConfig: config.mcpConfig,
    };

    super(baseConfig);

    // Validate that provider is xai if specified (Grok only supports xai)
    if (config.provider && config.provider !== "xai") {
      throw new Error("Grok agent only supports 'xai' provider");
    }

    // Store config values
    const envApiKey = process.env.GROK_API_KEY || process.env.XAI_API_KEY;
    const apiKey = config.providerApiKey || envApiKey;
    
    if (!apiKey) {
      throw new Error(
        "Grok agent requires providerApiKey or GROK_API_KEY environment variable"
      );
    }
    
    this.grokApiKey = apiKey;
    this.model = config.model;
    this.baseUrl = config.baseUrl;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    const modelFlag = this.model ? `--model ${this.model}` : "";
    const baseUrlFlag = this.baseUrl ? `--base-url ${this.baseUrl}` : "";

    return {
      command: `echo "${escapedPrompt}" | grok ${modelFlag} ${baseUrlFlag} --prompt "${instruction}"`,
      errorPrefix: "Grok",
      labelName: "grok",
      labelColor: "00D4AA",
      labelDescription: "Generated by Grok AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-grok";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envVars: Record<string, string> = {
      GROK_API_KEY: this.grokApiKey,
    };

    if (this.baseUrl) {
      envVars.GROK_BASE_URL = this.baseUrl;
    }

    return envVars;
  }

  protected getApiKey(): string {
    return this.grokApiKey;
  }

  protected getAgentType(): AgentType {
    return "grok";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "xai",
      apiKey: this.grokApiKey,
      model: this.model,
      baseUrl: this.baseUrl,
    };
  }

  // Override generateCode to support history and MCP tools
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: GrokStreamCallbacks,
    background?: boolean
  ): Promise<GrokResponse> {
    // Get available MCP tools
    const availableTools = await this.getAvailableTools();
    
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }
    
    // Add MCP tools information to instruction if available
    if (availableTools.length > 0) {
      const toolDescriptions = availableTools.map(tool => 
        `- ${tool.name}: ${tool.description}`
      ).join('\n');
      instruction += `\n\nAvailable MCP tools:\n${toolDescriptions}\n` +
        "You can reference these tools by using [TOOL_CALL:toolname]args[/TOOL_CALL] format.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    const modelFlag = this.model ? `--model ${this.model}` : "";
    const baseUrlFlag = this.baseUrl ? `--base-url ${this.baseUrl}` : "";

    // Override the command config with MCP-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${escapedPrompt}" | grok ${modelFlag} ${baseUrlFlag} --prompt "${instruction}"`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    // Process result for MCP tool calls if needed
    return await this.processMCPResponse(result as GrokResponse, availableTools);
  }

  /**
   * Process Grok response and execute any MCP tool calls
   */
  private async processMCPResponse(
    response: GrokResponse, 
    availableTools: any[]
  ): Promise<GrokResponse> {
    if (!availableTools.length || !response.stdout) {
      return response;
    }

    try {
      let processedStdout = response.stdout;
      const toolCallRegex = /\[TOOL_CALL:(\w+)\](.+?)\[\/TOOL_CALL\]/gs;
      const toolCalls = [...response.stdout.matchAll(toolCallRegex)];
      
      for (const [fullMatch, toolName, argsStr] of toolCalls) {
        try {
          const args = JSON.parse(argsStr.trim());
          const toolResult = await this.executeMCPTool(toolName, args);
          
          // Replace the tool call with the result
          const resultText = `[TOOL_RESULT:${toolName}]${JSON.stringify(toolResult)}[/TOOL_RESULT]`;
          processedStdout = processedStdout.replace(fullMatch, resultText);
          
        } catch (error) {
          console.warn(`Failed to execute MCP tool ${toolName}:`, (error as Error)?.message || error);
          const errorText = `[TOOL_ERROR:${toolName}]${(error as Error)?.message || error}[/TOOL_ERROR]`;
          processedStdout = processedStdout.replace(fullMatch, errorText);
        }
      }

      return {
        ...response,
        stdout: processedStdout,
        mcpToolsUsed: toolCalls.length
      };
      
    } catch (error) {
      console.warn('Error processing MCP response:', (error as Error)?.message || error);
      return response;
    }
  }
}